
# 数据结构部分  

## 最基本的线性结构 序列(sequence)

- 向量 vector 逻辑次序与物理存储次序完全吻合  
- 列表 list   逻辑上相邻，物理上未必相邻  

### 动态数组 vector的实现
- 对于元素的访问(读取和修改) 在常数时间内完成， A+i*s(访问只需要一次加法和一次乘法运算)  
- 逻辑次序也称为秩 为0-n的正整数
 

> - 构造函数 指定初始容量、申请内存空间、创建模板类型数组
> - 析构函数  释放内存空间
> - **控制可扩充向量的溢出策略**：数据溢出，申请一个更大的数组(2倍)，原数据集体搬迁到新空间，释放原空间
> - [Vector较数组更加灵活，只要系统尚有可用空间，规模不受初始容量限制] 
> - [每次从n到2n,扩容都花费O(n)时间，平摊时间为O(1),装载因子总是在高于50%，又不超过100%，size(n)<capacity(n)<2∙size(n)]
> - [单次操作的执行速度极其敏感的应用场合以上策略并不适用扩容和缩容，其中缩容操作甚至可以完全不予考虑]
> - 重载 赋值操作符 `=`
> - 重载 直接引用操作符 `[]`  时间复杂度O(1)
> - 置乱器算法  [从末元素开始`V[i-1]`，每次与前V`[0,i)`中某一元素随机交换] 时间复杂度 O(3n) 因为有swap

> - 插入元素 首先考虑是否溢出，然后后面的元素都要右移， 时间复杂度 O(_size-r+1)=O(n) 正比于向量的实际规模
> - 删除，插入的逆操作  删除单个元素是删除区间的特例 _elem[lo++] = _elem[hi++];  时间复杂度O(hi-lo)
> - [因为删除需要整体移动，所以能成片删除就能减少移动，把单个看成区间的特例]

> - [唯一化 剔除重复元素] 
> - 无序的，从首个元素开始，查看是否与其前缀雷同  备份size  调用find remove
> - [每次迭代 find对应于前驱的长度， remove对应于后继的移动，所以一次迭代时间O[n],总的迭代 时间O[n^2]]
> - 有序的低效实例和高效思路差别很大，高效的是直接进行，比较、copy、截断 时间复杂度O[n]

> - 无序查找 从后向前，顺序查找 时间复杂度 O(n)
> - 有序查找 二分查找 O(logn)

> - 排序
> - 冒泡排序，每一趟 肯定能把最大元素筛到最后面 [每一趟相邻的比较，看是否需要交换] 时间复杂度 O(n^2)
> - bubbleSort 是稳定的， 重复元素的相对次序在排序前后保持一致
> - 二路归并 采用[分治策略] (无序向量递归分解，有序向量逐层归并)  最坏最佳平均复杂度均为O(nlogn)
> - [归并 最后一层子问题时间为常数c 有n个所以是cn，总共有logn +1 层，所以时间复杂化度O(nlogn)]
> - [归并排序的计算量主要消耗于有序子向量的归并操作,子向量的划分不费时间]
> - [快速排序 排序可以在O(1)内完成，而将原问题划分成两个子问题需要O(n)] [快排序反复交换，稳定性不足]
> - 随机选一个轴点pivot，不断地迭代，找出它的位置，就可以实现一次轴点划分， 最坏的情况是类似冒泡排序O(n^2), 一般情况O(nlogn)]




> - 中位数查找  K查找
> - [记住，一组元素中 “第k大的元素” 所包含的信息量，远远少于经过全排序后得到的整个有序序列]
> - 两路归并序列的中位数 [找出每一个的中位数，减而治之]  复杂度O(logn)
> - 对于一般无须的一组元素， 使用优先级队列的结构进行K查找
> - [花费O(n)时间将全体元素组织为一个小顶堆, k次delMin()操作, 小顶堆顶即为第k个元素 O(n + klogn)]
> - [任取k个元素，并在O(k)时间以内将其组织为大顶堆, 将剩余的n-k个元素逐个插入堆中；每插入一个，随即删除堆顶 O(k + 2(n - k)logk)]
> - [分两组，构建一个K个元素大顶堆和(n-k)元素的小顶堆]
> - 当K趋于 n/2时，复杂度退化为 蛮力算法的O(nlogn)

### List vector的实现

- vector 是逻辑上和物理上都是对应的， 所谓[call by rank]  静态特性好，索引
- List 元素逻辑上线性次序，物理地址可以任意，所谓[call by link/position] 动态特性好(插入/删除) 

> 链表 linkedList是一种典型的动态存储结构， 数据分散为一系列的节点，节点间通过指针相互索引， 插入删除只调整局部少量指针， 大大降低了动态操作的成本

