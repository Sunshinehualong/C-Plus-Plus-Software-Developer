
# 数据结构部分  

## 最基本的线性结构 序列(sequence)

- 向量 vector 逻辑次序与物理存储次序完全吻合  
- 列表 list   逻辑上相邻，物理上未必相邻  

### 动态数组 vector的实现
- 对于元素的访问(读取和修改) 在常数时间内完成， A+i*s(访问只需要一次加法和一次乘法运算)  
- 逻辑次序也称为秩 为0-n的正整数
 

> - 构造函数 指定初始容量、申请内存空间、创建模板类型数组
> - 析构函数  释放内存空间
> - **控制可扩充向量的溢出策略**：数据溢出，申请一个更大的数组(2倍)，原数据集体搬迁到新空间，释放原空间
> - [Vector较数组更加灵活，只要系统尚有可用空间，规模不受初始容量限制] 
> - [每次从n到2n,扩容都花费O(n)时间，平摊时间为O(1),装载因子总是在高于50%，又不超过100%，size(n)<capacity(n)<2∙size(n)]
>  - [单次操作的执行速度极其敏感的应用场合以上策略并不适用扩容和缩容，其中缩容操作甚至可以完全不予考虑]
>  - 重载 赋值操作符 `=`
>  - 重载 直接引用操作符 `[]`  时间复杂度O(1)
>  - 置乱器算法  [从末元素开始`V[i-1]`，每次与前V`[0,i)`中某一元素随机交换] 时间复杂度 O(3n) 因为有swap
>  - 无序查找 从后向前，顺序查找 时间复杂度 O(n)

>  - 插入元素 首先考虑是否溢出，然后后面的元素都要右移， 时间复杂度 O(_size-r+1)=O(n) 正比于向量的实际规模
>  - 删除，插入的逆操作  删除单个元素是删除区间的特例 _elem[lo++] = _elem[hi++];  时间复杂度O(hi-lo)
>  - [因为删除需要整体移动，所以能成片删除就能减少移动，把单个看成区间的特例]

>  - 唯一化 剔除重复元素 
>  - 无序的，从首个元素开始，查看是否与其前缀雷同  备份size  调用find remove
>  - [每次迭代 find对应于前驱的长度， remove对应于后继的移动，所以一次迭代时间O[n],总的迭代 时间O[n^2]]
>  - 有序的低效实例和高效思路差别很大，高效的是直接进行，比较、copy、截断 时间复杂度O[n]
